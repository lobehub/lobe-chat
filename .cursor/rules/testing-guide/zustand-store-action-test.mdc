---
globs: src/store/**/__tests__/*.test.ts
alwaysApply: false
---

# ğŸª Zustand Store Action æµ‹è¯•æŒ‡å—

æµ‹è¯• `src/store` ä¸‹çš„ Zustand store actionsã€‚æœ¬æŒ‡å—åŸºäº `generateAIChat` é‡æ„å®è·µæ€»ç»“ã€‚

## æ ¸å¿ƒåŸåˆ™

### 1. æµ‹è¯•åˆ†å±‚åŸåˆ™ ğŸ¯

**æ¯å±‚æµ‹è¯•åªå…³æ³¨ç›´æ¥ä¾èµ–ï¼Œä¸è·¨å±‚ spy**

```
âŒ é”™è¯¯ç¤ºä¾‹ - è·¨å±‚ spy
describe('internal_coreProcessMessage', () => {
  it('test', async () => {
    // âŒ è·¨è¶Šäº† internal_fetchAIChatMessageï¼Œç›´æ¥ spy åº•å±‚æœåŠ¡
    const streamSpy = vi.spyOn(chatService, 'createAssistantMessageStream');
  });
});

âœ… æ­£ç¡®ç¤ºä¾‹ - spy ç›´æ¥ä¾èµ–
describe('internal_coreProcessMessage', () => {
  it('test', async () => {
    // âœ… åª spy ç›´æ¥è°ƒç”¨çš„æ–¹æ³•
    const fetchSpy = vi.spyOn(result.current, 'internal_fetchAIChatMessage')
      .mockResolvedValue({ isFunctionCall: false, content: 'response' });
  });
});
```

### 2. Mock ç­–ç•¥ ğŸ­

#### Per-Test Mockingï¼ˆæ¨èï¼‰

```typescript
// âœ… åœ¨æ¯ä¸ªæµ‹è¯•ä¸­æŒ‰éœ€ spy
describe('myAction', () => {
  it('should do something', async () => {
    // åªåœ¨éœ€è¦çš„æµ‹è¯•ä¸­ spy
    const serviceSpy = vi.spyOn(someService, 'method').mockResolvedValue(result);

    // æµ‹è¯•é€»è¾‘...

    serviceSpy.mockRestore(); // å¯é€‰ï¼šæ¸…ç†
  });
});
```

#### é¿å…å…¨å±€ Mock

```typescript
// âŒ é¿å…åœ¨ beforeEach ä¸­å…¨å±€ spy æ‰€æœ‰ä¸œè¥¿
beforeEach(() => {
  spyOnEverything(); // ä¼šé€ æˆæµ‹è¯•é—´éšå¼è€¦åˆ
});

// âœ… åª spy å‡ ä¹æ‰€æœ‰æµ‹è¯•éƒ½éœ€è¦çš„åŸºç¡€æœåŠ¡
beforeEach(() => {
  spyOnMessageService(); // å¤§å¤šæ•°æµ‹è¯•éƒ½éœ€è¦
  // å…¶ä»–æœåŠ¡æŒ‰éœ€åœ¨æµ‹è¯•å†… spy
});
```

## æµ‹è¯•æ–‡ä»¶ç»„ç»‡ç»“æ„ ğŸ“

### æ ‡å‡†ç»“æ„

```
src/store/[domain]/slices/[slice]/actions/__tests__/
â”œâ”€â”€ fixtures.ts          # æµ‹è¯•å¸¸é‡å’Œ mock æ•°æ®å·¥å‚
â”œâ”€â”€ helpers.ts           # å¯å¤ç”¨çš„æµ‹è¯•è¾…åŠ©å‡½æ•°
â””â”€â”€ [action].test.ts     # å®é™…æµ‹è¯•æ–‡ä»¶
```

### fixtures.ts æ¨¡æ¿

```typescript
import { DEFAULT_CONFIG } from '@/const/settings';

// æµ‹è¯•å¸¸é‡
export const TEST_IDS = {
  SESSION_ID: 'test-session-id',
  MESSAGE_ID: 'test-message-id',
  USER_ID: 'test-user-id',
} as const;

export const TEST_CONTENT = {
  MESSAGE: 'Test message',
  RESPONSE: 'Test response',
} as const;

// Mock æ•°æ®å·¥å‚
export const createMockMessage = (overrides: Partial<ChatMessage> = {}): ChatMessage => ({
  id: TEST_IDS.MESSAGE_ID,
  role: 'user',
  content: TEST_CONTENT.MESSAGE,
  sessionId: TEST_IDS.SESSION_ID,
  createdAt: Date.now(),
  updatedAt: Date.now(),
  ...overrides,
});

export const createMockMessages = (count: number): ChatMessage[] =>
  Array.from({ length: count }, (_, i) =>
    createMockMessage({
      id: `msg-${i}`,
      content: `Message ${i}`,
    }),
  );

export const createMockConfig = (overrides = {}) => ({
  ...DEFAULT_CONFIG,
  ...overrides,
});
```

### helpers.ts æ¨¡æ¿

```typescript
import { act } from '@testing-library/react';
import { vi } from 'vitest';

/**
 * Setup mock selectors with default or custom values
 */
export const setupMockSelectors = (
  options: {
    config?: Record<string, any>;
    meta?: Record<string, any>;
  } = {},
) => {
  vi.spyOn(selectors, 'currentConfig').mockImplementation(() =>
    createMockConfig(options.config),
  );

  vi.spyOn(selectors, 'currentMeta').mockImplementation(
    () => options.meta || {},
  );
};

/**
 * Setup store state with initial data
 */
export const setupStoreWithData = (data: any[], storeKey = 'default') => {
  useStore.setState({
    [storeKey]: data,
  });
};

/**
 * Setup spies for service methods (only common ones)
 */
export const spyOnCommonServices = () => {
  const serviceSpy = vi
    .spyOn(commonService, 'method')
    .mockResolvedValue(undefined);

  return { serviceSpy };
};

/**
 * Reset test environment to clean state
 */
export const resetTestEnvironment = () => {
  vi.clearAllMocks();
  useStore.setState(
    {
      // Reset to initial state
      data: [],
      loading: false,
    },
    false,
  );
};
```

## Action æµ‹è¯•æ¨¡æ¿ ğŸ“

### åŸºç¡€ Action æµ‹è¯•

```typescript
import { act, renderHook } from '@testing-library/react';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

import { useStore } from '../store';
import { TEST_IDS, createMockData } from './fixtures';
import { resetTestEnvironment, setupMockSelectors, spyOnCommonServices } from './helpers';

// Mock zustand
vi.mock('zustand/traditional');

beforeEach(() => {
  resetTestEnvironment();
  setupMockSelectors();
  spyOnCommonServices();

  // Setup common mocks that most tests need
  act(() => {
    useStore.setState({
      refreshData: vi.fn(),
      internalMethod: vi.fn(),
    });
  });
});

afterEach(() => {
  vi.restoreAllMocks();
});

describe('myAction', () => {
  describe('validation', () => {
    it('should return early when conditions not met', async () => {
      act(() => {
        useStore.setState({ requiredData: undefined });
      });

      const { result } = renderHook(() => useStore());

      await act(async () => {
        await result.current.myAction();
      });

      expect(result.current.internalMethod).not.toHaveBeenCalled();
    });
  });

  describe('main flow', () => {
    it('should process data correctly', async () => {
      const { result } = renderHook(() => useStore());
      const mockData = createMockData();

      await act(async () => {
        await result.current.myAction(mockData);
      });

      expect(result.current.internalMethod).toHaveBeenCalledWith(
        expect.objectContaining({
          id: TEST_IDS.DATA_ID,
          status: 'processed',
        }),
      );
    });
  });

  describe('error handling', () => {
    it('should handle errors gracefully', async () => {
      const { result } = renderHook(() => useStore());

      vi.spyOn(result.current, 'internalMethod').mockRejectedValue(
        new Error('Test error'),
      );

      await act(async () => {
        await result.current.myAction();
      });

      expect(result.current.errorState).toBeDefined();
    });
  });
});
```

### æµ‹è¯• Internal Methodsï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰

```typescript
// ä¿å­˜çœŸå®å®ç°ç”¨äºæµ‹è¯•
const realInternalMethod = useStore.getState().internal_method;

describe('internal_method', () => {
  it('should call correct dependencies', async () => {
    // æ¢å¤çœŸå®å®ç°
    act(() => {
      useStore.setState({ internal_method: realInternalMethod });
    });

    const { result } = renderHook(() => useStore());

    // âœ… Spy ç›´æ¥ä¾èµ–
    const dependencySpy = vi
      .spyOn(result.current, 'internal_dependency')
      .mockResolvedValue(expectedResult);

    await act(async () => {
      await result.current.internal_method(input);
    });

    expect(dependencySpy).toHaveBeenCalledWith(
      expect.objectContaining({ /* expected params */ }),
    );
  });
});
```

### æµ‹è¯• Streaming/å¼‚æ­¥æµç¨‹

```typescript
describe('streamingAction', () => {
  it('should handle streaming chunks', async () => {
    const { result } = renderHook(() => useStore());
    const dispatchSpy = vi.spyOn(result.current, 'internal_dispatch');

    // Mock streaming service
    const streamSpy = vi
      .spyOn(streamService, 'stream')
      .mockImplementation(async ({ onChunk, onFinish }) => {
        await onChunk?.({ type: 'data', content: 'chunk1' });
        await onChunk?.({ type: 'data', content: 'chunk2' });
        await onFinish?.('complete');
      });

    await act(async () => {
      await result.current.streamingAction();
    });

    expect(dispatchSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'update',
        value: expect.objectContaining({ content: 'chunk1' }),
      }),
    );

    streamSpy.mockRestore();
  });
});
```

### æµ‹è¯• Toggle/Loading States

```typescript
describe('internal_toggleLoading', () => {
  it('should enable loading state with abort controller', () => {
    const { result } = renderHook(() => useStore());

    act(() => {
      result.current.internal_toggleLoading(true, TEST_IDS.ITEM_ID, 'action');
    });

    const state = useStore.getState();
    expect(state.loadingIds).toEqual([TEST_IDS.ITEM_ID]);
    expect(state.abortController).toBeInstanceOf(AbortController);
  });

  it('should disable loading state and clear abort controller', () => {
    const { result } = renderHook(() => useStore());

    act(() => {
      result.current.internal_toggleLoading(true, TEST_IDS.ITEM_ID, 'start');
      result.current.internal_toggleLoading(false, undefined, 'stop');
    });

    const state = useStore.getState();
    expect(state.loadingIds).toEqual([]);
    expect(state.abortController).toBeUndefined();
  });
});
```

## å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ âš ï¸

### é—®é¢˜ 1: React State Update è­¦å‘Š

```typescript
// âŒ é”™è¯¯ï¼šæœªåŒ…è£¹ setState
useStore.setState({ data: newData });

// âœ… æ­£ç¡®ï¼šç”¨ act() åŒ…è£¹æ‰€æœ‰ setState
act(() => {
  useStore.setState({ data: newData });
});
```

### é—®é¢˜ 2: è·¨å±‚ Spy

```typescript
// âŒ é”™è¯¯ï¼šè·¨å±‚ spy åº•å±‚æœåŠ¡
describe('highLevelAction', () => {
  const lowLevelServiceSpy = vi.spyOn(lowLevelService, 'method');
});

// âœ… æ­£ç¡®ï¼šspy ç›´æ¥ä¾èµ–
describe('highLevelAction', () => {
  const directDependencySpy = vi.spyOn(result.current, 'directMethod');
});
```

### é—®é¢˜ 3: Mock ç±»å‹ä¸åŒ¹é…

```typescript
// âŒ é”™è¯¯ï¼šè¿”å›ç±»å‹ä¸åŒ¹é…
vi.spyOn(service, 'method').mockResolvedValue('string');
// ä½† method è¿”å› Response

// âœ… æ­£ç¡®ï¼šè¿”å›æ­£ç¡®ç±»å‹
vi.spyOn(service, 'method').mockResolvedValue(new Response('string'));
```

### é—®é¢˜ 4: å…¨å±€ Mock æ±¡æŸ“

```typescript
// âŒ é”™è¯¯ï¼šbeforeEach ä¸­ spy æ‰€æœ‰æœåŠ¡
beforeEach(() => {
  spyOnServiceA();
  spyOnServiceB();
  spyOnServiceC(); // é€ æˆæµ‹è¯•é—´è€¦åˆ
});

// âœ… æ­£ç¡®ï¼šæŒ‰éœ€ spy
beforeEach(() => {
  spyOnCommonService(); // åª spy é€šç”¨æœåŠ¡
});

describe('specific test', () => {
  it('test', () => {
    const specificSpy = vi.spyOn(specificService, 'method'); // æŒ‰éœ€ spy
  });
});
```

## æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡ ğŸ“Š

### è¦†ç›–ç‡è¦æ±‚

- **æœ€ä½ç›®æ ‡**: 70%
- **æ¨èç›®æ ‡**: 85%+
- **ä¼˜ç§€ç›®æ ‡**: 90%+

### æ£€æŸ¥è¦†ç›–ç‡

```bash
# è¿è¡Œå•ä¸ªæµ‹è¯•æ–‡ä»¶çš„è¦†ç›–ç‡
bunx vitest run --coverage 'src/store/[domain]/__tests__/[action].test.ts'

# æŸ¥çœ‹ç‰¹å®šæ–‡ä»¶çš„è¦†ç›–ç‡
bunx vitest run --coverage --silent='passed-only' 'src/store/[domain]/__tests__/[action].test.ts' | grep "[action].ts"
```

### ä¼˜å…ˆæµ‹è¯•åœºæ™¯

1. âœ… **ä¸»æµç¨‹**: æ­£å¸¸çš„ä¸šåŠ¡æµç¨‹
2. âœ… **è¾¹ç•Œæ¡ä»¶**: ç©ºæ•°æ®ã€æœªå®šä¹‰å€¼ã€è¾¹ç•Œå€¼
3. âœ… **é”™è¯¯å¤„ç†**: å¼‚å¸¸æƒ…å†µã€å¤±è´¥é‡è¯•
4. âœ… **çŠ¶æ€ç®¡ç†**: Loadingã€Toggleã€Abort
5. âš ï¸ **è¾¹ç¼˜æƒ…å†µ**: å¯é€‰ï¼Œä½†ä¸è¦ä¸ºäº†è¦†ç›–ç‡è€Œå†™æ— æ„ä¹‰çš„æµ‹è¯•

## çœŸå®æ¡ˆä¾‹ï¼šgenerateAIChat é‡æ„ ğŸ“

### é‡æ„å‰çš„é—®é¢˜

```typescript
// âŒ é—®é¢˜ 1: è·¨å±‚ spy
describe('internal_coreProcessMessage', () => {
  const streamSpy = vi.spyOn(chatService, 'createAssistantMessageStream');
  // è·³è¿‡äº† internal_fetchAIChatMessage å±‚
});

// âŒ é—®é¢˜ 2: Mock é”™è¯¯å¯¹è±¡
describe('internal_fetchAIChatMessage', () => {
  vi.stubGlobal('fetch', ...); // ä½†å®é™…ä¸è°ƒç”¨ fetch
});

// âŒ é—®é¢˜ 3: å…¨å±€ spy æ±¡æŸ“
beforeEach(() => {
  spyOnChatService(); // é€ æˆæ‰€æœ‰æµ‹è¯•éƒ½æœ‰è¿™ä¸ª spy
});
```

### é‡æ„åçš„è§£å†³æ–¹æ¡ˆ

```typescript
// âœ… è§£å†³ 1: Spy ç›´æ¥ä¾èµ–
describe('internal_coreProcessMessage', () => {
  const fetchSpy = vi
    .spyOn(result.current, 'internal_fetchAIChatMessage')
    .mockResolvedValue({ isFunctionCall: false, content: 'response' });
});

// âœ… è§£å†³ 2: Mock æ­£ç¡®æœåŠ¡
describe('internal_fetchAIChatMessage', () => {
  const streamSpy = vi
    .spyOn(chatService, 'createAssistantMessageStream')
    .mockImplementation(async ({ onMessageHandle, onFinish }) => {
      await onMessageHandle?.({ type: 'text', text: 'response' });
      await onFinish?.('response', {});
    });
});

// âœ… è§£å†³ 3: æŒ‰éœ€ spy
beforeEach(() => {
  spyOnMessageService(); // åª spy é€šç”¨æœåŠ¡
  // chatService æŒ‰éœ€åœ¨æµ‹è¯•ä¸­ spy
});
```

### é‡æ„æ•ˆæœ

- ğŸ“ˆ è¦†ç›–ç‡æå‡: 54.44% â†’ 82.03% (+27.59%)
- âœ… æµ‹è¯•é€šè¿‡ç‡: 52/52 (100%)
- ğŸ¯ ç±»å‹é”™è¯¯: 6 â†’ 0
- ğŸ“ æµ‹è¯•æ›´æ¸…æ™°: æ˜ç¡®çš„æµ‹è¯•åˆ†å±‚

## æœ€ä½³å®è·µ Checklist âœ…

æµ‹è¯•å‰æ£€æŸ¥ï¼š

- [ ] æ˜¯å¦éµå¾ªæµ‹è¯•åˆ†å±‚åŸåˆ™ï¼Ÿ
- [ ] Mock å¯¹è±¡æ˜¯å¦å¯¹åº”å®é™…è°ƒç”¨ï¼Ÿ
- [ ] æ˜¯å¦é¿å…äº†å…¨å±€ spy æ±¡æŸ“ï¼Ÿ
- [ ] æ‰€æœ‰ setState æ˜¯å¦ç”¨ act() åŒ…è£¹ï¼Ÿ
- [ ] æµ‹è¯•æ˜¯å¦è¶³å¤ŸåŸå­åŒ–ï¼Ÿ
- [ ] æµ‹è¯•æè¿°æ˜¯å¦æ¸…æ™°ï¼Ÿ
- [ ] æ˜¯å¦æœ‰ fixtures å’Œ helpers å¤ç”¨ä»£ç ï¼Ÿ
- [ ] è¦†ç›–ç‡æ˜¯å¦è¾¾åˆ°ç›®æ ‡ï¼Ÿ

## å‚è€ƒèµ„æº ğŸ“š

- [Vitest å®˜æ–¹æ–‡æ¡£](https://vitest.dev/)
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- [Zustand Testing Guide](https://docs.pmnd.rs/zustand/guides/testing)
- é¡¹ç›®æµ‹è¯•è§„èŒƒ: `.cursor/rules/testing-guide/testing-guide.mdc`
