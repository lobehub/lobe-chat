---
description:
globs: src/store/**
alwaysApply: false
---

# LobeChat Zustand Action Patterns

## Action Type Hierarchy

LobeChat Actions use a layered architecture with clear separation of responsibilities:

### 1. Public Actions

Main interfaces exposed for UI component consumption:

- Naming: Verb form (`createTopic`, `sendMessage`, `updateTopicTitle`)
- Responsibilities: Parameter validation, flow orchestration, calling internal actions
- Example: [src/store/chat/slices/topic/action.ts](mdc:src/store/chat/slices/topic/action.ts)

```typescript
// Public Action example
createTopic: async () => {
  // ...
  return topicId;
},
```

### 2. Internal Actions (`internal_*`)

Internal implementation details handling core business logic:

- Naming: `internal_` prefix + verb (`internal_createTopic`, `internal_updateMessageContent`)
- Responsibilities: Optimistic updates, service calls, error handling, state synchronization
- Should not be called directly by UI components

```typescript
// Internal Action example - Optimistic update pattern
internal_createTopic: async (params) => {
  const tmpId = Date.now().toString();

  // 1. Immediately update frontend state (optimistic update)
  get().internal_dispatchTopic(
    { type: 'addTopic', value: { ...params, id: tmpId } },
    'internal_createTopic',
  );
  get().internal_updateTopicLoading(tmpId, true);

  // 2. Call backend service
  const topicId = await topicService.createTopic(params);
  get().internal_updateTopicLoading(tmpId, false);

  // 3. Refresh data to ensure consistency
  get().internal_updateTopicLoading(topicId, true);
  await get().refreshTopic();
  get().internal_updateTopicLoading(topicId, false);

  return topicId;
},
```

### 3. Dispatch Methods (`internal_dispatch*`)

Methods dedicated to handling state updates:

- Naming: `internal_dispatch` + entity name (`internal_dispatchTopic`, `internal_dispatchMessage`)
- Responsibilities: Calling reducers, updating Zustand store, handling state comparison

```typescript
// Dispatch Method example
internal_dispatchTopic: (payload, action) => {
  const nextTopics = topicReducer(topicSelectors.currentTopics(get()), payload);
  const nextMap = { ...get().topicMaps, [get().activeId]: nextTopics };

  if (isEqual(nextMap, get().topicMaps)) return;

  set({ topicMaps: nextMap }, false, action ?? n(`dispatchTopic/${payload.type}`));
},
```

## When to Use Reducer Pattern vs. Simple `set`

### Use Reducer Pattern When

Suitable for complex data structure management, especially:

- Managing object lists or maps (e.g., `messagesMap`, `topicMaps`)
- Scenarios requiring optimistic updates
- Complex state transition logic
- Type-safe action payloads needed

```typescript
// Reducer pattern example - Complex message state management
export const messagesReducer = (state: ChatMessage[], payload: MessageDispatch): ChatMessage[] => {
  switch (payload.type) {
    case 'updateMessage': {
      return produce(state, (draftState) => {
        const index = draftState.findIndex((i) => i.id === payload.id);
        if (index < 0) return;
        draftState[index] = merge(draftState[index], {
          ...payload.value,
          updatedAt: Date.now(),
        });
      });
    }
    case 'createMessage': {
      // ...
    }
    // ...other complex state transitions
  }
};
```

### Use Simple `set` When

Suitable for simple state updates:

- Toggling boolean values
- Updating simple strings/numbers
- Setting single state fields

```typescript
// Simple set example
updateInputMessage: (message) => {
  if (isEqual(message, get().inputMessage)) return;
  set({ inputMessage: message }, false, n('updateInputMessage'));
},

togglePortal: (open?: boolean) => {
  set({ showPortal: open ?? !get().showPortal }, false, 'togglePortal');
},
```

## Optimistic Update Implementation Patterns

Optimistic updates are a core pattern in LobeChat for providing smooth user experience:

### Standard Optimistic Update Flow

```typescript
// Complete optimistic update example
internal_updateMessageContent: async (id, content, extra) => {
  const { internal_dispatchMessage, refreshMessages } = get();

  // 1. Immediately update frontend state (optimistic update)
  internal_dispatchMessage({
    id,
    type: 'updateMessage',
    value: { content },
  });

  // 2. Call backend service
  await messageService.updateMessage(id, {
    content,
    tools: extra?.toolCalls ? internal_transformToolCalls(extra.toolCalls) : undefined,
    // ...other fields
  });

  // 3. Refresh to ensure data consistency
  await refreshMessages();
},
```

### Optimistic Update for Create Operations

```typescript
internal_createMessage: async (message, context) => {
  const { internal_createTmpMessage, refreshMessages, internal_toggleMessageLoading } = get();

  let tempId = context?.tempMessageId;
  if (!tempId) {
    // Create temporary message for optimistic update
    tempId = internal_createTmpMessage(message);
    internal_toggleMessageLoading(true, tempId);
  }

  try {
    const id = await messageService.createMessage(message);
    if (!context?.skipRefresh) {
      await refreshMessages();
    }
    internal_toggleMessageLoading(false, tempId);
    return id;
  } catch (e) {
    internal_toggleMessageLoading(false, tempId);
    // Error handling: update message error state
    internal_dispatchMessage({
      id: tempId,
      type: 'updateMessage',
      value: { error: { type: ChatErrorType.CreateMessageError, message: e.message } },
    });
  }
},
```

### Delete Operation Pattern (No Optimistic Update)

Delete operations typically don't suit optimistic updates because:

- Deletion is destructive; error recovery is complex
- Users have lower expectations for immediate feedback on deletions
- Restoring state on deletion failure causes confusion

```typescript
// Standard delete operation pattern - No optimistic update
removeGenerationTopic: async (id: string) => {
  const { internal_removeGenerationTopic } = get();
  await internal_removeGenerationTopic(id);
},

internal_removeGenerationTopic: async (id: string) => {
  // 1. Show loading state
  get().internal_updateGenerationTopicLoading(id, true);

  try {
    // 2. Directly call backend service
    await generationTopicService.deleteTopic(id);

    // 3. Refresh data to get latest state
    await get().refreshGenerationTopics();
  } finally {
    // 4. Ensure loading state is cleared (whether success or failure)
    get().internal_updateGenerationTopicLoading(id, false);
  }
},
```

Delete operation characteristics:

- Directly call service without pre-updating state
- Rely on loading state for user feedback
- Refresh entire list after operation to ensure consistency
- Use `try/finally` to ensure loading state is always cleaned up

## Loading State Management Pattern

LobeChat uses a unified loading state management pattern:

### Array-based Loading State

```typescript
// Define in initialState.ts
export interface ChatMessageState {
  messageEditingIds: string[]; // Message editing state
}

// Manage in action
{
  toggleMessageEditing: (id, editing) => {
    set(
      { messageEditingIds: toggleBooleanList(get().messageEditingIds, id, editing) },
      false,
      'toggleMessageEditing',
    );
  };
}
```

## SWR Integration Pattern

LobeChat uses SWR for data fetching and cache management:

### Hook-based Data Fetching

```typescript
// Define SWR hook in action.ts
useFetchMessages: (enable, sessionId, activeTopicId) =>
  useClientDataSWR<ChatMessage[]>(
    enable ? [SWR_USE_FETCH_MESSAGES, sessionId, activeTopicId] : null,
    async ([, sessionId, topicId]) => messageService.getMessages(sessionId, topicId),
    {
      onSuccess: (messages, key) => {
        const nextMap = {
          ...get().messagesMap,
          [messageMapKey(sessionId, activeTopicId)]: messages,
        };

        if (get().messagesInit && isEqual(nextMap, get().messagesMap)) return;

        set({ messagesInit: true, messagesMap: nextMap }, false, n('useFetchMessages'));
      },
    },
  ),
```

### Cache Invalidation and Refresh

```typescript
// Standard data refresh pattern
refreshMessages: async () => {
  await mutate([SWR_USE_FETCH_MESSAGES, get().activeId, get().activeTopicId]);
};
```

## Naming Convention Summary

### Action Naming Patterns

- Public Actions: Verb form, describing user intent
  - `createTopic`, `sendMessage`, `regenerateMessage`
- Internal Actions: `internal_` + verb, describing internal operation
  - `internal_createTopic`, `internal_updateMessageContent`
- Dispatch Methods: `internal_dispatch` + entity name
  - `internal_dispatchTopic`, `internal_dispatchMessage`
- Toggle Methods: `internal_toggle` + state name
  - `internal_toggleMessageLoading`, `internal_toggleChatLoading`

### State Naming Patterns

- ID arrays: `[entity]LoadingIds`, `[entity]EditingIds`
- Map structures: `[entity]Maps`, `[entity]Map`
- Currently active: `active[Entity]Id`
- Initialization flags: `[entity]sInit`

## Best Practices

1. Use optimistic updates appropriately:
   - ✅ Suitable: Create, update operations (frequent user interaction)
   - ❌ Avoid: Delete operations (destructive, complex error recovery)
2. Loading state management: Use unified loading state arrays to manage concurrent operations
3. Type safety: Define TypeScript interfaces for all action payloads
4. SWR integration: Use SWR to manage data fetching and cache invalidation
5. AbortController: Provide cancellation capability for long-running operations
6. Operation mode selection:
   - Create/Update: Optimistic update + eventual consistency
   - Delete: Loading state + service call + data refresh

This Action organization pattern ensures code consistency, maintainability, and provides excellent user experience.
